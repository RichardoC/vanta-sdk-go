const fs = require('fs');
const path = '/workspace/Vanta Postman Env & Collection/Vanta API.postman_collection.json';
const j = JSON.parse(fs.readFileSync(path,'utf8'));

const re = /[^a-zA-Z0-9]+/g;
function fixInitialisms(s){
  return s
    .replaceAll('Id', 'ID')
    .replaceAll('Url', 'URL')
    .replaceAll('Api', 'API')
    .replaceAll('Oauth', 'OAuth');
}
const title = (s)=>{
  s = (s||'').replace(/([a-z0-9])([A-Z])/g,'$1 $2').replace(re,' ').trim();
  if(!s) return '';
  const parts = s.split(/\s+/).map(p=>p.toLowerCase());
  let out = parts.map(p=>p? p[0].toUpperCase()+p.slice(1):'').join('');
  out = fixInitialisms(out);
  return /^[0-9]/.test(out)?'N'+out:out;
};
const oneLine=s=>(s||'').replace(/\s+/g,' ').trim();

function normalize(raw){
  let r=(raw||'').trim();
  r=r.replace(/^\{\{baseUrl\}\}/,'').replace(/^\{\{authUrl\}\}/,'');
  if(!r) return {path:'',query:''};
  if(!r.startsWith('/')) r='/'+r;
  const i=r.indexOf('?');
  if(i<0) return {path:r,query:''};
  return {path:r.slice(0,i),query:r.slice(i+1)};
}
function parseQ(q){
  if(!q) return [];
  return q.split('&').filter(Boolean).map(x=>{const i=x.indexOf('=');return i<0?{key:x,value:''}:{key:x.slice(0,i),value:x.slice(i+1)}})
}
function infer(v){
  v=(v||'').trim();
  if(v==='true'||v==='false') return 'bool';
  if(/^[-]?\d+$/.test(v)) return 'int';
  return 'string';
}
function serviceFromPath(p){
  const parts=p.replace(/^\//,'').split('/').filter(Boolean);
  if(parts.length===0) return 'Root';
  if(parts[0]==='v1'&&parts.length>1) return title(parts[1]);
  return title(parts[0]);
}
function pathParams(p){
  return p.split('/').filter(x=>x.startsWith(':')).map(x=>x.slice(1));
}

const ops=[];
function walk(items, trail=[]){
  for(const it of items||[]){
    const t=[...trail,it.name||''];
    if(it.request){
      const req=it.request;
      const norm=normalize(req.url?.raw||'');
      if(norm.path){
        let m=title(it.name||'')||title(t.join(' '))||title(req.method||'Op')||'Op';
        const qitems=(req.url?.query&&req.url.query.length?req.url.query:parseQ(norm.query));
        const seen=new Set();
        const queries=[];
        for(const q of qitems){
          if(!q.key||seen.has(q.key)) continue;
          seen.add(q.key);
          queries.push({name:q.key,goName:title(q.key),type:infer(q.value)});
        }
        ops.push({
          service:serviceFromPath(norm.path),
          methodName:m,
          method:(req.method||'GET').toUpperCase(),
          path:norm.path,
          description:oneLine(req.description||it.description||''),
          query:queries,
          pathParams:pathParams(norm.path),
          bodyMode:req.body?.mode||'none'
        });
      }
    }
    if(it.item) walk(it.item,t);
  }
}
walk(j.item,[]);

const byService=new Map();
for(const op of ops){if(!byService.has(op.service)) byService.set(op.service,[]); byService.get(op.service).push(op);}
const services=[...byService.keys()].sort();
for(const s of services){
  const arr=byService.get(s);
  arr.sort((a,b)=>a.methodName.localeCompare(b.methodName)||a.path.localeCompare(b.path));
  const used={};
  for(const op of arr){
    used[op.methodName]=(used[op.methodName]||0)+1;
    if(used[op.methodName]>1) op.methodName=op.methodName+'By'+title(op.method)+(used[op.methodName]);
  }
}

let out='';
out += '// Code generated by tools/generate.js. DO NOT EDIT.\n\n';
out += 'package v1\n\n';
out += 'import (\n';
out += '\t"context"\n\t"encoding/json"\n\t"fmt"\n\t"net/url"\n\t"strings"\n';
out += ')\n\n';
out += '// Services is the generated service registry for Vanta APIs.\n';
out += 'type Services struct {\n';
for(const s of services) out += `\t${s} *${s}Service\n`;
out += '}\n\n';
out += 'func newGeneratedServices(c *Client) *Services {\n\tservices := &Services{}\n';
for(const s of services) out += `\tservices.${s} = &${s}Service{client: c}\n`;
out += '\treturn services\n}\n\n';
for(const s of services){
  const arr=byService.get(s);
  out += `// ${s}Service groups ${arr.length} endpoint methods under the "${s}" API segment.\n`;
  out += `type ${s}Service struct {\n\tclient *Client\n}\n\n`;
  for(const op of arr){
    const hasBody = op.bodyMode==='raw';
    const hasForm = op.bodyMode==='formdata';
    const hasParams = op.pathParams.length||op.query.length||hasBody||hasForm;
    const paramStruct = `${s}${op.methodName}Params`;
    if(hasParams){
      out += `type ${paramStruct} struct {\n`;
      for(const p of op.pathParams) out += `\t${title(p)} string\n`;
      for(const q of op.query) out += `\t${q.goName} *${q.type}\n`;
      if(hasBody) out += '\tBody any\n';
      if(hasForm){
        out += '\t// FormData maps multipart field names to values.\n';
        out += '\tFormData map[string]string\n';
      }
      out += '}\n\n';
    }
    const doc = op.description || `${op.methodName} performs ${op.method} ${op.path}.`;
    out += `// ${op.methodName} ${doc}\n`;
    if(hasParams){
      out += `func (s *${s}Service) ${op.methodName}(ctx context.Context, params *${paramStruct}) (json.RawMessage, error) {\n`;
      out += `\tif params == nil {\n\t\tparams = &${paramStruct}{}\n\t}\n`;
    } else {
      out += `func (s *${s}Service) ${op.methodName}(ctx context.Context) (json.RawMessage, error) {\n`;
    }
    out += `\tpath := "${op.path}"\n`;
    for(const p of op.pathParams){
      const g=title(p);
      out += `\tif params.${g} == "" {\n\t\treturn nil, fmt.Errorf("${p} is required")\n\t}\n`;
      out += `\tpath = strings.ReplaceAll(path, ":${p}", url.PathEscape(params.${g}))\n`;
    }
    out += '\tquery := url.Values{}\n';
    for(const q of op.query){
      out += `\tif params.${q.goName} != nil {\n\t\tquery.Set("${q.name}", fmt.Sprint(*params.${q.goName}))\n\t}\n`;
    }
    if(hasForm){
      out += '\treq, err := s.client.newMultipartRequest(ctx, "'+op.method+'", path, query, params.FormData)\n';
      out += '\tif err != nil {\n\t\treturn nil, err\n\t}\n';
      out += '\tvar out json.RawMessage\n';
      out += '\tif err := s.client.doJSON(req, &out); err != nil {\n\t\treturn nil, err\n\t}\n';
      out += '\treturn out, nil\n';
      out += '}\n\n';
      continue;
    }
    if(hasBody) out += `\treq, err := s.client.newRequest(ctx, "${op.method}", path, query, params.Body)\n`;
    else out += `\treq, err := s.client.newRequest(ctx, "${op.method}", path, query, nil)\n`;
    out += '\tif err != nil {\n\t\treturn nil, err\n\t}\n';
    out += '\tvar out json.RawMessage\n';
    out += '\tif err := s.client.doJSON(req, &out); err != nil {\n\t\treturn nil, err\n\t}\n';
    out += '\treturn out, nil\n';
    out += '}\n\n';
  }
}

fs.writeFileSync('/workspace/v1/generated_services.go', out);
console.log(`generated /workspace/v1/generated_services.go with ${ops.length} operations across ${services.length} services`);
